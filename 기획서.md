# 러닝 세션 플래너 MVP – 기획 및 개발 문서

## 기획서 (Planning Document)

### 화면 흐름 (User Flow)

1. **서비스 진입:** 사용자가 웹 애플리케이션에 접속하면 로그인 없이 곧바로 러닝 세션 플래너를 사용할 수 있습니다. 첫 화면은 미니멀한 챗봇 UI로 구성되며, 전체 배경은 `neutral-100`(옅은 회색 톤)으로 설정됩니다.
2. **AI 환영 인사:** 화면 로드와 함께 AI가 **친근한 환영 인사** 메시지를 먼저 표시합니다. 예를 들어, "안녕하세요! 러닝 세션 계획을 도와드릴 Running Coach입니다 😀"와 같이 인사를 건네며, 이어서 **러닝 목표**를 물어봅니다. (이 단계에서 사용자는 아직 입력하지 않고 AI의 메시지를 읽습니다.)
3. **사용자 응답 – 러닝 목표:** 사용자는 챗봇 인터페이스의 입력창에 자신의 러닝 목적을 입력합니다 (예: "다이어트 위해 꾸준히 달리고 싶어요" 또는 "5km 마라톤 연습"). 입력 후 엔터 또는 전송 버튼을 눌러 응답을 제출하면, 사용자의 메시지가 채팅창에 표시됩니다.
4. **AI 질문 – 러닝 시간/거리:** AI는 사용자의 목표를 확인하며 공감 또는 간단한 격려를 한 뒤, **러닝 시간과 거리**에 대해 묻습니다. 예를 들어: "*목표가 \_\_\_이시군요! 이번 러닝은 얼마나 뛰실 계획인가요? 시간(분)이나 거리(km)를 알려주세요.*"와 같이 자연스럽게 질문합니다.
5. **사용자 응답 – 시간/거리 제시:** 사용자는 원하는 러닝 **시간과/또는 거리**를 답변합니다. 예를 들어 "30분 정도 뛰고 싶어요" **또는** "5km 정도 뛰고 싶어요" **또는** "30분에 5km 달리고 싶어요" 등으로 응답합니다. (사용자가 시간과 거리를 모두 제시하지 않은 경우, AI는 추가로 다른 값도 물어보거나 추정합니다.)
6. **AI 질문 – 인터벌 여부:** AI는 이어서 **인터벌 훈련**을 포함할지 물어봅니다. 예를 들어: "*혹시 달리기 중간중간에 걷거나 속도를 높이는 인터벌을 넣어볼까요?*". 사용자가 인터벌 훈련을 희망하면, AI가 구체적으로 어떤 형태를 원하는지 추가 질문하거나 기본적인 제안을 합니다. 희망하지 않으면 일반 러닝으로 진행합니다.
7. **사용자 응답 – 인터벌 조건:** 사용자는 "네, 1분 달리고 1분 걷는 식으로 하고 싶어요" **또는** "아니요, 꾸준히 달릴게요" 등으로 인터벌 여부를 답합니다. AI는 필요한 경우 인터벌 관련 추가 정보를 얻고, 충분하다 판단되면 더 묻지 않습니다.
8. **AI 최종 계획 제시:** AI는 수집된 정보를 바탕으로 **최종 러닝 세션 계획**을 작성합니다. 이 메시지에는 러닝 세션의 세부 내용(예: 워밍업, 본운동, 쿨다운 등), **총 러닝 거리**, **예상 소요 시간**, **평균 페이스** 등이 포함됩니다. AI는 친근하고 명확한 어조로 플랜을 설명하며, 마지막 부분에 요약 정보를 강조합니다.

   * 예: "*이제 준비가 되었어요! 5분 워밍업 조깅 후, 1분 간격으로 달리기와 걷기를 10회 반복하고, 마지막으로 5분간 천천히 달려 마무리하세요. 전체 **5km**를 약 **30분**에 달리게 되고, 평균 페이스는 **6:00/km** 정도가 될 거예요!*".
9. **요약 및 일정 등록 제안:** AI의 최종 메시지 하단에는 요약 정보를 한눈에 볼 수 있도록 \*\*"총 거리: X km, 총 시간: Y분, 평균 페이스: Z분/km"\*\*와 함께 **`일정 등록하기` 버튼**이 나타납니다. 이 버튼은 대화의 일부처럼 보이지만, UI에서는 상호작용 가능한 요소입니다.
10. **사용자 액션 – 일정 등록:** 사용자가 `일정 등록하기` 버튼을 클릭하면, **사용자의 캘린더 앱에 러닝 일정을 추가**할 수 있는 동작이 실행됩니다. 구체적으로는 iCalendar 표준의 **ICS 파일**을 생성하여 다운로드하거나, 모바일 환경에서 캘린더 앱이 인식할 수 있는 링크를 제공하여 바로 일정 추가를 시도합니다.

    * 모바일 기기(예: iPhone의 Safari)에서는 `.ics` 파일을 클릭하면 자동으로 캘린더에 이벤트 추가 화면이 뜨도록 유도됩니다. Android의 경우 ICS 파일이 다운로드되며, 알림바나 파일을 통해 열면 캘린더에 가져올 수 있습니다.
    * `일정 등록하기`를 누르는 즉시 ICS 파일이 생성되어 사용자 기기에 다운로드되고, 동시에 웹화면에는 러닝 계획의 요약이 **카드 형태**로 별도 표시됩니다 (아래 참조).
11. **일정 등록 후 피드백:** 일정 등록 버튼 동작 후, 화면에는 "러닝 일정이 등록되었습니다!" 등의 피드백 메시지나 아이콘을 잠시 보여주고 사라지게 할 수 있습니다. 사용자는 마지막으로 제공된 **요약 카드**를 확인하거나, 필요하면 채팅을 새로 시작할 수 있습니다.

### UI 구성 및 컴포넌트 구조 (UI Design & Components)

* **전체 화면 배경:** Tailwind CSS의 `bg-neutral-100` 컬러를 사용하여 밝은 회색톤 배경을 적용합니다. 페이지 레이아웃은 모바일 화면에 맞춰 중앙에 채팅 카드가 나타나도록 **반응형 디자인**을 고려합니다. 불필요한 장식 없이 깔끔한 느낌을 줍니다.
* **채팅 영역 (Chat Window):** 화면 중앙에 **화이트 카드** 형태의 채팅 창을 배치합니다. 카드에는 약간의 `border`(연회색 테두리, 예: `border-gray-300`)와 `border-radius`(라운딩)를 주어 부드러운 모서리를 나타냅니다. 그림자(Shadow)는 적용하지 않아 **평면적이고 미니멀**한 인상을 줍니다. 채팅 영역은 일정 높이에서 **스크롤 가능**하도록 설정해, 대화가 길어지면 이전 메시지를 위로 스크롤해볼 수 있게 합니다.
* **대화 말풍선 (Chat Bubble):** AI와 사용자의 메시지는 각각 말풍선 형태의 박스로 표시됩니다. **모든 말풍선은 흰색 바탕에 테두리와 둥근모서리** 스타일로 통일하되, 보더 색상을 약간 다르게 하거나 좌우 정렬을 달리하여 화자 구분을 합니다.

  * AI의 말풍선: 좌측 정렬로 띄우고, 흰 배경에 `border-gray-300` 테두리. 내용 텍스트는 기본 검정 (`text-gray-800`)으로 가독성 높게.
  * 사용자 말풍선: 우측 정렬로 띄워 AI 메시지와 시각적으로 분리합니다. 색상은 흰 배경에 동일한 스타일이 가능하나, 필요에 따라 미묘하게 다른 테두리 색이나 약간 다른 배경 (예: `bg-gray-50`)을 줄 수도 있습니다. 혹은 별도 색 없이 **오른쪽 정렬만으로도 구분**되도록 합니다. 사용자 메시지도 기본 폰트 색상 유지.
  * 말풍선 내부 패딩은 적당히 주어 (예: `p-3` 또는 `p-4`) 텍스트가 눌리지 않도록 하고, 각 말풍선 간 간격(`mb-2` 등)을 두어 읽기 쉽도록 합니다.
* **메시지 입력창 (Input Box):** 채팅 영역 하단에는 사용자가 답변을 입력할 수 있는 단순한 입력 필드가 고정 배치됩니다. 예를 들어, `placeholder`로 "메시지를 입력하세요..."를 표시하고, Tailwind로 스타일링하여 `rounded-full` 또는 `rounded-lg` 형태의 텍스트박스로 구현합니다. 입력창 왼쪽에는 이모티콘이나 마이크 등은 MVP에서는 생략하고, 오른쪽에 전송 버튼(▶ 모양 아이콘 또는 "Send" 텍스트)을 배치합니다. 입력 필드는 흰색 배경에 얇은 테두리(`border-gray-300`)로 다른 컴포넌트 스타일과 조화를 이루며, focus 시 테두리 색상이 약간 진해지는 정도의 효과를 줍니다.
* **요약 카드 (Summary Card):** 최종 대화 이후, 웹 화면 하단 또는 채팅 영역 아래에 **요약 정보 카드**를 별도로 표시합니다. 이 컴포넌트는 최종 러닝 계획의 핵심 정보를 한눈에 보여주는 **요약 카드**로, 흰색 배경과 테두리/라운드 스타일은 유지하되, 채팅 말풍선보다 넓은 폭으로 배치하여 독립된 섹션임을 나타냅니다. 카드 안에는 러닝 세션의 **총 거리, 총 시간, 평균 페이스**를 큰 글씨로 요약하고, 그 외 세부 계획(인터벌 구성 등)을 작은 글씨 또는 리스트로 정리합니다. 이 요약 카드는 사용자가 대화를 마친 후에도 남아있어, 대화 내용을 스크롤하지 않고도 핵심 계획을 확인할 수 있습니다.
* **"일정 등록하기" 버튼:** 이 버튼은 최종 AI 메시지 말풍선 내에도 존재하지만, UI 컴포넌트로서는 별도로 정의됩니다. Tailwind로 스타일링된 기본 버튼으로, 파란색 등의 강조색 없이 **흰색 카드 스타일에 테두리만 있는** 버튼으로 디자인합니다 (혹은 테두리만 있고 배경 투명). 호버 시 살짝 배경이 `gray-100` 정도로 변하는 정도의 최소한의 피드백만 주어 일관된 미니멀 스타일을 유지합니다. 모바일 친화적으로 충분한 높이와 폭, 터치 여유 공간을 확보합니다. 버튼 클릭 시 동작(ICS 파일 생성 및 다운로드)을 처리하며, 클릭 직후 약간의 로딩이 발생할 경우 스피너 등을 버튼 옆에 표시할 수도 있습니다 (MVP에선 ICS 생성이 매우 빠르므로 생략 가능).
* **기타 구성:** 로고나 헤더는 MVP 단계에서는 생략하거나, 화면 상단에 간단한 타이틀 ("Running Planner AI" 등)을 배치할 수 있습니다. 하단에는 간략한 푸터나 저작권 정보 정도를 (필요시) 추가하지만 핵심 흐름에는 포함하지 않습니다. 전체 UI는 불필요한 요소를 배제하고 **러닝 계획 대화 흐름에만 집중**하도록 구성합니다.

> **컴포넌트 목록 요약:**
>
> * **ChatWindow** – 채팅 전체 영역 컨테이너 (스크롤 관리, 배경).
> * **ChatBubble (AI/User)** – AI와 사용자 메시지 박스 컴포넌트 (내용 및 스타일 다르게).
> * **ChatInput** – 사용자 입력창 및 전송 버튼 컴포넌트.
> * **SummaryCard** – 최종 결과 요약 카드 컴포넌트.
> * **AddToCalendarButton** – 일정 등록 버튼 컴포넌트 (SummaryCard 내 혹은 대화 내 사용).

### 대화 예시 (Conversation Example)

아래는 **러닝 세션 플래너 AI**와 사용자의 예시 대화 흐름입니다. AI는 친근하고 능동적으로 질문을 이끌며, 사용자의 답변을 반영하여 최종 계획을 제시합니다.

| **AI**                                                                                                                                                                                                                                                                                                                                                              | **사용자**                                            |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------- |
| 안녕하세요! 😊 러닝 코치 AI입니다. 오늘 러닝 계획을 세워볼까요? 우선, 러닝을 하시는 **목적**이 어떻게 되세요?                                                                                                                                                                                                                                                                                                | *(질문에 답하며)* 안녕하세요! 저는 **체중 감량**을 위해 달리기를 하고 싶어요.   |
| 멋진 목표네요! 💪 그러면 이번에는 얼마나 **뛰실 예정**인가요? 시간(분)이나 거리(km)로 말씀해주시면 돼요.                                                                                                                                                                                                                                                                                                   | 음... **30분** 정도 뛰어보려고 해요.                          |
| 30분 달리기를 계획하시는군요. 보통 이 정도면 5km 안팎을 뛰게 될 거예요. 혹시 **인터벌 러닝**도 해보고 싶으신가요? 예를 들어, 빠르게 달리기와 걷기를 섞는 훈련이에요.                                                                                                                                                                                                                                                                | 네, 인터벌을 넣고 싶어요. **1분 빠르게 달리고 1분 걷기**를 번갈아 하는 식으로요. |
| 좋아요! 😊 1분 런/1분 워크 인터벌로 계획해볼게요. 자, 이제 플랜을 정리해드릴게요... 잠시만요.                                                                                                                                                                                                                                                                                                          |                                                    |
| *(AI가 러닝 세션 계획을 작성)*                                                                                                                                                                                                                                                                                                                                                |                                                    |
| **\[러닝 세션 계획]** 오늘은 **체중 감량**을 위한 인터벌 러닝을 해볼게요! 먼저 **5분간 가벼운 조깅**으로 워밍업합니다. 그 다음, **1분 빠르게 달리기 + 1분 걷기** 인터벌을 **10세트** 진행할 거예요. 이 인터벌로 약 **20분**을 보내면, 마무리로 **5분간 천천히 조깅**하며 쿨다운하세요. 총 러닝 시간은 **30분** 정도이고, 이 동안 약 **5km**를 달릴 수 있을 거예요. 평균 페이스는 **6:00/km** 정도로 예상됩니다. 💡 **파이팅입니다!** 🏃‍♀️🏃‍♂️<br/>**총 거리: 5km, 총 시간: 30분, 평균 페이스: 6:00/km**   \[📅 **일정 등록하기**] | 감사합니다! 계획이 정말 마음에 들어요. 😊                          |

*(위 대화에서, 마지막 AI 메시지에 러닝 계획과 요약, 일정 등록 버튼이 포함되어 있습니다.)*

### 입력/출력 스키마 (Input/Output Schema)

러닝 세션 플래너의 대화 및 결과로 주고받는 **데이터 구조**를 정의합니다. 이는 AI가 질문을 통해 수집하는 **입력 정보**와, 최종적으로 생성되는 러닝 **계획 출력**의 구조로 나눌 수 있습니다.

#### 입력 항목 (Input Data Fields)

* **러닝 목표** (`goal`): 사용자가 러닝을 하는 목적 또는 목표입니다. *(예: "체중 감량", "지구력 향상", "5K 대회 준비")*
* **러닝 시간** (`duration_minutes`): 사용자가 달리고자 하는 시간(분)입니다. 정수 또는 숫자 형태로, 분 단위로 저장합니다. *(예: 30)*
* **러닝 거리** (`distance_km`): 목표하는 달리기 거리(km)입니다. 부동소수점 또는 정수로 저장할 수 있습니다. *(예: 5 또는 5.0)*
* **인터벌 여부 및 조건** (`interval_plan`): 인터벌 훈련을 할지 여부와 구체 조건입니다. 불리언 값으로 **인터벌 여부**를 표시하고, 인터벌을 한다면 세부 패턴(런/워크 시간 등)을 문자열이나 구조화된 데이터로 저장합니다. *(예: `true` 와 `"1min run / 1min walk x10"`)*
* *(선택)* **일정 시간** (`schedule_time`): 사용자가 러닝을 **시작할 예정 시각** 혹은 날짜/시간. (MVP에서는 별도로 묻지 않지만, 일정 등록 기능 향상을 위해 고려 가능). Date/Time 형태로 저장. *(예: `2025-05-10 07:00:00`)*

위 입력 항목들은 대화 중 점진적으로 수집됩니다. 모든 정보가 수집되면 AI는 출력 생성 단계로 넘어갑니다.

#### 출력 항목 (Output Data Fields)

* **러닝 계획 설명** (`plan_description`): AI가 생성한 러닝 세션의 전체 설명입니다. 워밍업부터 본 운동, 쿨다운까지 순서대로 작성된 **자연어 문장**의 블록으로, 사용자가 이해하기 쉽게 구성됩니다. *(예: "5분 조깅으로 워밍업하고, 1분간 빠르게 달린 후 1분 걷기를 10회 반복한 다음 5분간 천천히 달려 마무리합니다.")*
* **총 러닝 시간** (`total_time`): 예상되는 총 러닝 시간. 일반적으로 사용자가 제공한 시간과 일치하지만, 인터벌 등의 계획으로 인해 약간 변동이 있으면 그에 맞게 조정합니다. 분 단위 혹은 "HH시간 MM분" 형태로 표현될 수 있습니다. *(예: 30분)*
* **총 러닝 거리** (`total_distance`): 이번 러닝 세션에서 달릴 총 거리. 사용자의 입력(거리 or 시간)과 계획에 따라 추정하거나 사용자가 제공한 값을 재확인합니다. *(예: 5km)*
* **평균 페이스** (`average_pace`): 총 시간과 거리에 기반한 평균 속도(페이스)입니다. 일반적으로 `분/킬로미터`(min/km) 단위로 표시하며, 소숫점보다는 "6:00/km"처럼 **분:초 형태**로 표기합니다. *(예: 6:00/km)*
* **인터벌 세부 계획** (`interval_details`): 인터벌 훈련을 하는 경우 세부 패턴을 요약합니다. 문자열로 "1분 달리기 + 1분 걷기 x10" 등 형식이 될 수 있습니다. 인터벌을 하지 않는 경우 이 필드는 빈 값이거나 null.
* **ICS 이벤트 정보** (`event_data`): 캘린더 등록을 위한 이벤트 데이터 구조입니다. ICS 파일 생성을 위해 필요한 필드들을 포함합니다.

  * **제목** (`summary`): 이벤트 제목. 러닝 종류나 목표, 거리 등을 간단히 포함 (예: "러닝 세션 - 5km 인터벌").
  * **시작시각** (`start_time`): 이벤트 시작 DateTime (UTC 또는 로컬).
  * **종료시각/기간** (`end_time` 또는 `duration`): 시작시각으로부터 러닝 지속 시간(예: 30분)을 반영한 종료시각, 또는 기간(Duration) 정보.
  * **설명** (`description`): 이벤트 상세 설명으로 러닝 계획 설명(`plan_description`)을 그대로 넣거나 요약. 캘린더 메모란에서 볼 수 있도록 함.
  * **UID**: 이벤트 고유 ID (ICS 규격상 필수). 임의의 고유 문자열 (예: UUID)로 생성.
  * **기타**: ICS 표준 필드인 `DTSTAMP` (파일 생성시간), `VERSION`, `PRODID` 등도 추가.

이러한 출력 데이터 중 사용자에게 직접 노출되는 것은 **러닝 계획 설명**과 요약 정보(총 시간/거리/페이스 등)이며, ICS 이벤트 정보는 내부적으로 일정 등록 기능에 사용됩니다.

### UX 고려사항 (UX Considerations)

* **대화 흐름 간결성:** 질문은 하나씩 순차적으로 물어 사용자로 하여금 **부담 없이 답변**하도록 합니다. 한 번에 여러 질문을 나열하지 않고, **한 가지 정보를 얻으면 다음으로 넘어가는** 형식으로 대화를 설계했습니다. 이는 챗봇과 상호작용하는 사용자 경험을 자연스럽고 인간적인 대화처럼 느끼게 합니다.
* **친근하고 격려하는 톤:** AI의 어조는 예의있고 상냥하며, 사용자의 목표를 **칭찬하거나 응원**하는 문장을 섞어 동기를 부여합니다. 예를 들어 "좋은 목표네요!", "파이팅입니다!" 같은 피드백을 추가하여 사용자 경험을 긍정적으로 만듭니다.
* **오류 대응:** 사용자가 질문에 엉뚱한 답을 하거나 숫자를 입력하지 않는 등 예상치 못한 응답을 할 수 있습니다. 이를 대비해 AI는 **재질문 또는 확인** 절차를 간단히 거치도록 프롬프트를 설계합니다. (예: 거리나 시간을 말해달라는 질문에 사용자가 "잘 모르겠어요"라고 하면, "그렇다면 30분 정도로 해볼까요?" 등 제안을 합니다.) 이러한 대응은 대화를 막힘없이 이어가게 해줍니다.
* **모바일 UI 최적화:** 본 서비스는 모바일 사용을 염두에 두므로, **터치 영역**을 충분히 크게 하고 폰트 크기를 가독성 높게 설정합니다. 챗봇 인터페이스는 작은 화면에서도 편리하게 사용할 수 있도록 입력창을 화면 하단에 고정하고, 스크롤이 부드럽게 동작하게 합니다. 또한 `일정 등록` 버튼은 손쉽게 눌러지도록 화면 폭을 적절히 사용하고, iOS/안드로이드 모두에서 ICS 파일 처리가 잘 이뤄지도록 테스트해야 합니다.
* **일관성 있는 디자인:** UI 색상과 컴포넌트는 의도적으로 절제하여 사용합니다. 화려한 색상이나 아이콘을 지양하고, 흰색/중립색과 간결한 아이콘만으로 구성하여 **집중도를 높입니다**. 사용자의 시선을 흐트러뜨리지 않고 오로지 대화 내용과 결과에 집중할 수 있게 합니다.
* **피드백과 완료 인지:** 마지막에 일정 등록 버튼을 누르면 즉각적인 피드백(예: "✅ 캘린더에 일정 추가 링크를 생성했습니다")을 제공하여 사용자가 동작이 수행되었음을 알 수 있게 합니다. 그리고 요약 카드를 별도로 보여주는 것은 **대화 완료를 명시**하는 역할도 합니다.
* **확장성 대비:** MVP 단계에서는 1회 대화로 1개의 플랜을 만들지만, 사용자가 **새로운 플랜을 만들고자 할 때**를 고려해 "새로운 계획 세우기" 또는 챗봇 리셋 기능을 준비할 수 있습니다. 예를 들어 요약 카드 하단에 작은 버튼으로 "새 플랜 시작"을 제공하면, 클릭 시 대화 기록을 초기화하고 처음 환영 단계로 돌아갑니다. (MVP에서는 페이지 리프레시로 대체해도 무방합니다.)
* **접근성:** 텍스트 대비(배경과 글자색), 폰트 크기, 버튼 ARIA 레이블 등 **웹 접근성** 사항도 기본적인 수준에서 신경 씁니다. 색상 대비를 충분히 하고, 시각적 구분 요소(예: 정렬, 아이콘)를 사용하여 시력이 좋지 않은 사용자가 봐도 누가 말한 것인지 인지할 수 있도록 디자인합니다.

---

## 개발 문서 (Development Document)

### 기술 스택 (Tech Stack)

* **Next.js** (React 기반 프레임워크): 본 프로젝트의 기본 플랫폼으로 사용합니다. 서버사이드 렌더링(SSR)과 정적 페이지 제공을 모두 지원하여 초기 로딩이 빠르고 SEO에도 유리합니다. 이 MVP에서는 대부분 **클라이언트 측 인터랙션**(챗봇 대화, 버튼 클릭)이 주를 이루므로, Next.js를 SPA처럼 활용하지만, API Routes를 사용해 백엔드 기능(예: AI 호출, ICS 생성)을 구현합니다.

  * Next.js 13+ (App Router)를 사용해도 되고, Pages Router를 사용해도 무방합니다. **API 경로**를 활용해 외부 API 호출 및 파일 생성을 처리합니다.
* **Tailwind CSS:** 빠른 UI 스타일링을 위해 Tailwind CSS를 적용합니다. 별도의 CSS 없이도 utility 클래스로 디자인 시스템을 구축하며, `neutral-100` 배경이나 `border, rounded` 등의 스타일을 클래스 이름만으로 간결하게 적용할 수 있습니다. 디자인 가이드에 맞춰 테마를 커스터마이징할 필요는 없으며, 기본 팔레트의 중립색과 spacing 유틸리티를 활용합니다.
* **Gemini API:** Google의 최신 **생성형 AI API**인 Gemini를 사용하여 대화형 러닝 코치 AI를 구현합니다. 이 API를 통해 AI에게 사용자 질문 맥락을 보내고 답변(질문이나 계획)을 받아옵니다. Gemini API는 ChatGPT와 유사하게 프롬프트를 주고 받는 **대화 지향** 인터페이스를 지원하며, 높은 지능으로 사용자 입력을 이해하고 러닝 플랜을 생성합니다.

  * Gemini API 호출은 **백엔드 서버**(예: Next.js API Route 또는 Supabase Edge Function)를 통해 이루어집니다. 클라이언트에서 직접 호출하지 않는 이유는 API 키 노출 방지와 보다 안정적인 통신을 위해서입니다.
  * 이 프로젝트에서는 **OpenAI API와 유사한 방식**으로 Gemini를 통합합니다. 예를 들어, `POST https://generativeai.googleapis.com/v1beta2/models/textchat:predict` 같은 엔드포인트를 사용할 수 있으며(실제 엔드포인트는 Google Cloud 설정에 따름), 필요에 따라 Google AI SDK를 활용할 수도 있습니다.
* **Supabase:** Supabase는 PostgreSQL 기반의 클라우드 데이터베이스 및 인증/스토리지 플랫폼입니다. 이 MVP에서는 **로그인을 사용하지 않으므로** 인증 기능은 제외되지만, Supabase를 활용하여 다음을 구현합니다:

  * **대화 및 플랜 데이터 저장:** 최종 생성된 러닝 계획을 저장하는 테이블 (예: `Plans` 테이블)을 생성합니다. 사용자별 저장은 아니지만, 각 플랜에 고유 ID를 부여하여 ICS 생성 등에 활용합니다.
  * **백엔드 기능:** Next.js API Route 외에도 Supabase의 Edge Functions를 활용할 수 있습니다. (예: Gemini API 호출을 Supabase Edge Function에서 처리하도록 하여 분리하거나, 향후 확장을 대비한 서버리스 함수로 구성할 수 있습니다.)
  * **환경 설정:** Supabase를 통해 .env 관리나 배포 시 시크릿(Key) 저장을 할 수도 있습니다. 여기서는 **Gemini API 키**나 기타 비밀 정보들은 Supabase 프로젝트의 환경변수 또는 Vercel 환경변수에 안전하게 보관합니다.
* **기타 라이브러리:**

  * **ICS 생성 라이브러리 (선택)**: ICS 파일 생성을 수동으로 구현 가능하지만, npm 패키지인 `ics` 또는 `ical-generator`를 사용하면 객체지향적으로 이벤트를 구성하고 ICS 문자열을 얻을 수 있습니다. MVP에서는 의존성을 줄이기 위해 간단한 함수를 작성하여 문자열 포맷팅으로 ICS를 생성해도 무방합니다.
  * **Next.js AI SDK (옵션):** Next.js와 Vercel에서 제공하는 AI SDK나 유틸리티 (예: `useChat` 훅 등)가 있다면 Gemini API와 연동하여 **스트리밍 응답** 등을 구현하는 데 사용할 수 있습니다. 하지만 호환성 여부를 확인해야 하므로, 초기 버전에서는 직접 fetch로 API를 호출하는 방향으로 구현해도 충분합니다.

### 시스템 아키텍처 및 API 명세 (System Architecture & API)

**전반적인 아키텍처:** 클라이언트(Next.js 페이지)와 서버(API Routes or Supabase Functions)가 협력하여 동작합니다. 클라이언트는 사용자 입력을 받아 서버에 보냄 -> 서버가 AI 응답을 받아 클라이언트에 전달 -> 클라이언트가 대화 UI 업데이트 -> 최종적으로 서버에서 ICS 파일 생성. 이 흐름에 관여하는 주요 API 엔드포인트 및 기능은 아래와 같습니다.

* **AI 채팅 API** (`POST /api/chat`): 사용자의 메시지를 받아 Gemini AI의 답변을 반환하는 엔드포인트입니다.

  * **Request:** JSON 형식으로 대화 맥락과 새 사용자 메시지를 보냅니다. 예시:

    ```json
    {
      "messages": [
        {"role": "system", "content": "...(시스템 프롬프트)..."},
        {"role": "assistant", "content": "안녕하세요! 러닝 코치입니다..."},
        {"role": "user", "content": "다이어트 위해 달리고 싶어요"}
      ]
    }
    ```

    혹은 간단히 새로운 사용자 발화만 보내고 서버에서 과거 대화 내역을 세션이나 DB에서 불러올 수도 있습니다. MVP에서는 클라이언트가 대화 내역을 관리하며 매 요청마다 해당 내역을 보낼 수 있습니다.
  * **Response:** JSON 형식으로 AI의 답변을 반환합니다. 예시:

    ```json
    {
      "reply": "멋진 목표네요! 얼마나 뛰실 예정인가요? 시간이나 거리를 알려주세요."
    }
    ```

    응답에는 AI 메시지와 필요하면 대화 종료 여부(예: `isFinal: false/true`) 플래그를 포함시킬 수 있습니다. 이 플래그는 AI 프롬프트에서 마지막 답변에 표시하도록 유도하거나, 서버가 대화 흐름을 간단히 스테이트 머신으로 관리하면 설정할 수 있습니다. (MVP에서는 주로 프롬프트 기반으로 흐름 제어)
  * **동작:** 서버는 요청을 받으면 내부적으로 Gemini API에 해당 메시지들을 보내 **AI 추론 결과**를 받아옵니다. 이때 **Gemini API 키**는 서버에 안전하게 저장되어 있고, 외부로 노출되지 않습니다. 오류 발생 시 (ex: API 시간 초과) 적절한 에러 메시지를 반환하며, 클라이언트는 이를 사용자에게 안내합니다 (예: "죄송합니다, 잠시 후 다시 시도해주세요.").
  * **상태 관리:** 각 사용자의 대화 세션은 프론트엔드 상태로 관리됩니다 (로그인이 없으므로 세션ID 등은 따로 없고, 페이지 새로고침하면 리셋). 필요한 경우 서버 세션 쿠키나 Supabase 테이블로 임시 대화로그를 저장 가능하지만, MVP에선 생략합니다.

* **플랜 저장 API** (`POST /api/plan`): 최종 러닝 계획을 서버에 저장하는 엔드포인트입니다.

  * **Request:** 최종 AI 답변으로부터 추출한 러닝 **계획 데이터**를 JSON으로 보냅니다. 예:

    ```json
    {
      "goal": "체중 감량",
      "duration": 30,
      "distance": 5,
      "interval_plan": "1분 러닝/1분 걷기 x10",
      "plan_description": "5분 워밍업 조깅 후 ... 5분간 천천히 조깅하며 마무리.",
      "total_time": 30,
      "total_distance": 5,
      "average_pace": "6:00/km"
    }
    ```

    (실제로는 필요한 필드만 포함. `goal, duration, distance` 등은 중복일 수 있으나, 편의상 모두 저장할 수 있습니다.)
  * **Response:** 저장된 플랜의 고유 ID를 반환합니다. 예: `{ "planId": "de305d54-75b4-431b-adb2-eb6b9e546014" }` (UUID 형식).
  * **동작:** 서버는 Supabase의 DB (또는 임베디드 DB)로 연결하여 `Plans` 테이블에 새 레코드를 삽입합니다. 레코드에는 ID(프라이머리키 UUID, 기본값 생성)와 각 필드, 생성 timestamp 등이 저장됩니다. Supabase JS 클라이언트를 사용하거나, Supabase Edge Function (SQL) 호출로 DB에 쓰기 작업을 수행할 수 있습니다. 완료 후 생성된 ID를 반환합니다.
  * **용도:** 이 ID는 다음 ICS 생성에 활용되며, 추후 사용자 히스토리를 관리하거나 통계를 수집하는 데도 사용할 수 있습니다. (로그인 도입 시 사용자별 연관 가능)

* **일정(iCal) 생성 API** (`GET /api/ical/[id]`): 주어진 플랜 ID에 대한 iCalendar(ICS) 파일을 동적으로 생성하여 반환하는 엔드포인트입니다.

  * **Request:** 경로 파라미터로 `id`를 포함합니다. 예: `/api/ical/de305d54-75b4-431b-adb2-eb6b9e546014`
  * **Response:** `Content-Type: text/calendar` 형식의 .ics 파일 내용을 바이트 스트림으로 보냅니다. 응답 시 `Content-Disposition: attachment; filename="running-plan.ics"` 헤더를 포함시켜, 브라우저가 이를 파일 다운로드 (또는 연결 앱 실행)으로 인식하도록 합니다.
  * **동작:** 서버는 경로로 받은 `id`를 이용해 Supabase DB의 `Plans` 테이블에서 해당 ID의 플랜 레코드를 조회합니다. (만약 저장 후 시간이 아주 짧아 DB에 반영 안 되었을 경우를 대비해 약간 재시도하거나, 저장 API가 끝난 뒤 클릭 가능하도록 프론트에서 제어). 조회된 데이터로 ICS 파일 내용을 생성합니다.

    * ICS 파일 생성은 문자열 조합으로 직접 수행하거나, 앞서 언급한 라이브러리를 사용할 수 있습니다. 간단히 예를 들면:

      ```javascript
      const event = planRecord;
      const dt = new Date(); // 또는 event.start_time 있으면 그것으로
      const dtStart = formatDateTime(dt);       // YYYYMMDDTHHmmss
      const dtEnd   = formatDateTime(new Date(dt.getTime() + event.total_time*60000));
      const icsContent = [
        "BEGIN:VCALENDAR",
        "VERSION:2.0",
        "PRODID:-//RunPlanner//EN",
        "BEGIN:VEVENT",
        `UID:${event.id}@runplanner`, 
        `DTSTAMP:${formatDateTime(new Date())}Z`,
        `DTSTART:${dtStart}`,
        `DURATION:PT${event.total_time}M`,
        `SUMMARY:Running Session - ${event.total_distance}km`,
        `DESCRIPTION:${event.plan_description.replace(/\n/g,"\\n")}`,
        "END:VEVENT",
        "END:VCALENDAR"
      ].join("\r\n");
      ```

      위 예시는 start 시간을 현재 시각(`dt`)으로 설정하고, total\_time을 이용해 DURATION을 계산하는 방식입니다. 실제로는 사용자가 달리기를 계획한 시간을 알 수 있다면 `DTSTART`를 그 시간으로 설정하는 것이 좋습니다. (MVP에서는 명시적 시간 입력이 없으므로, 기본값으로 **현재 시각** 혹은 **작성 시각**을 시작 시간으로 사용합니다.)
    * 만들어진 `icsContent` 문자열을 응답으로 내보냅니다. Node.js에서는 `res.setHeader`로 컨텐트 타입과 디스포지션을 설정한 뒤 `res.send(icsContent)`를 호출합니다.
  * **에러 처리:** 주어진 ID에 해당하는 플랜이 없으면 404 응답을 보냅니다. ICS 생성 중 문제가 발생하면 500 오류를 리턴합니다.
  * **대안:** 만약 DB를 사용하지 않는다면, 최종 AI 응답시 생성한 계획 데이터를 클라이언트에 들고 있다가, `/api/ical` 호출시 **쿼리 문자열**로 필요한 정보를 넘겨 ICS를 생성할 수도 있습니다. 그러나 URL이 길어질 수 있고, 보안상 매우 민감한 정보는 아니지만 ID를 통한 조회가 더 깔끔합니다.
  * **웹캘린더 링크:** 추후 원클릭 일정 추가를 위해 `webcal://` 링크 프로토콜을 활용하는 방안도 있습니다. 예를 들어 생성된 ICS를 CDN이나 Supabase Storage에 업로드하고 `webcal://`로 연결하면, 모바일에서 좀더 직접적으로 캘린더 앱이 구독하도록 할 수 있습니다. 하지만 단일 이벤트인 경우에는 현재 방식(ICS 파일 다운로드/열기)으로도 충분합니다.

* **정적 페이지/기타:** Next.js 특성상 `/` (홈) 페이지가 메인 애플리케이션 UI를 제공하는 **싱글페이지**입니다. 그 외에 특별한 정적 페이지는 없으며, 에러 페이지나 404 페이지 정도를 Next.js 기본으로 둡니다.

**데이터베이스 (Supabase) 설계:**
Supabase의 PostgreSQL을 사용하여 간단한 `plans` 테이블을 구성합니다. 스키마 예시는 다음과 같습니다:

```sql
CREATE TABLE plans (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  created_at TIMESTAMPTZ DEFAULT now(),
  goal TEXT,
  duration_minutes INT,
  distance_km NUMERIC,
  interval_plan TEXT,
  plan_description TEXT,
  total_time_minutes INT,
  total_distance_km NUMERIC,
  average_pace TEXT
);
```

* 이 테이블에 최종 플랜을 저장하며, `id` 필드는 ICS 링크 제공에 사용됩니다.
* 실제 운영 시에는 테이블이 빠르게 커질 일은 없지만, 주기적으로 오래된 레코드를 정리하거나, 사용자별로 분리하는 등을 고려할 수 있습니다 (로그인 기능 추가 전까지는 필요 없음).

### 일정 등록 기능 구현 (Calendar Integration with ICS)

모든 플랫폼에서 통용되는 \*\*캘린더 일정 파일(ICS)\*\*을 생성하여 사용자의 캘린더에 러닝 일정을 추가하도록 구현합니다.

**iCalendar(ICS) 파일 생성:**
ICS는 일정 정보를 담는 표준 형식 텍스트 파일입니다. 러닝 플래너에서는 다음과 같은 내용을 포함합니다:

* **SUMMARY:** 일정 제목 – 러닝 세션임을 알 수 있도록 간단히 구성 (예: `"Running Session - 5km 인터벌 러닝"`).
* **DESCRIPTION:** 일정 설명 – 러닝 계획의 상세 내용을 문자열로 넣습니다. 여러 줄의 텍스트를 포함할 수 있으며, ICS 규격에 따라 개행 문자는 `\n`로 이스케이프해야 합니다.
* **DTSTART:** 시작 일시 – 러닝 시작 시간. (MVP에서는 플랜 생성 시각 혹은 클릭 시각을 사용. 예: 사용자가 2025-05-10 오전 7시에 계획 생성했다면 그 시각을 시작으로) ISO datetime을 `YYYYMMDDTHHMMSS` 형식으로 표현합니다. 시간대가 명시되지 않으면 현지 시간으로 간주되며, 명시하려면 `TZID=Asia/Seoul:` 등의 접두어를 넣을 수 있습니다.
* **DTEND 또는 DURATION:** 종료 일시 또는 기간 – 러닝 지속 시간에 해당하는 이벤트 길이를 지정합니다. 예를 들어 30분 러닝이면 `DURATION:PT30M` 와 같이 ISO 8601 기간 표기(`PT`는 Period-Time)로 기록하거나, `DTEND`에 시작시간+30분을 계산해 넣을 수 있습니다. 두 방식 중 하나만 쓰면 됩니다.
* **UID:** 각 이벤트를 식별하는 고유 ID – 일반적으로 도메인명을 포함한 고유 문자열을 사용합니다. 예: `<UUID>@runplanner` 형태. 이 값이 동일하면 중복 일정으로 인식되므로, UUID 등을 새로 생성하면 됩니다.
* **DTSTAMP:** ICS 파일 생성 타임스탬프 – 현재 시간의 UTC 표시를 넣습니다.
* **PRODID:** 생성 어플리케이션 ID – 예: `-//RunPlanner//MVP 1.0//KO`처럼 식별자. (캘린더 상에는 표시되지 않으나 표준상 권장)
* **END:** 각각 VCALENDAR와 VEVENT 블록의 종료.

**ICS 예시:** 아래는 하나의 러닝 이벤트에 대한 ICS 예시입니다. (실제 구현 시 줄바꿈은 `\r\n`으로 구분)

```text
BEGIN:VCALENDAR
VERSION:2.0
PRODID:-//RunPlanner//MVP 1.0//KO
BEGIN:VEVENT
UID:de305d54-75b4-431b-adb2-eb6b9e546014@runplanner
DTSTAMP:20250509T143000Z
DTSTART:20250510T070000
DURATION:PT30M
SUMMARY:Running Session - 5km 인터벌 러닝
DESCRIPTION:목표: 체중 감량\n5분 조깅 워밍업 후 1분 달리기/1분 걷기 x10\n5분 쿨다운 조깅\n총 5km 달리기, 예상 30분 소요, 평균페이스 6:00/km
END:VEVENT
END:VCALENDAR
```

위 내용에서:

* `DTSTART:20250510T070000`은 2025년 5월 10일 07:00 (현지시간) 시작을 의미합니다.
* `DURATION:PT30M`은 30분 길이의 이벤트임을 나타냅니다.
* `DESCRIPTION` 필드는 여러 줄로 구성되어 있으며, 러닝 계획의 핵심을 담았습니다. (여러 줄을 표시하려면 `\n`을 넣어야 함)
* 한국 시간대 예시로 작성했지만, `TZID`를 지정하지 않았으므로 일정 등록시 **로컬 시간** 7시에 일정으로 등록됩니다 (사용자의 캘린더 설정에 따라 해석). 만약 UTC로 처리하고 싶다면 `DTSTART:20250509T220000Z` 처럼 Zulu 표기나 TZID 지정이 필요하지만, 여기서는 단순화를 위해 생략했습니다.
* `UID`와 `DTSTAMP`는 이벤트 식별과 참조를 위해 필요합니다. 구현 시 UUID를 생성하거나, plan ID를 이용해 UID를 구성할 수 있습니다.

**ICS 파일 제공:**
Next.js API Route(`/api/ical/[id]`)에서 위와 같은 ICS 텍스트를 생성하여 반환할 때, **HTTP 헤더** 설정이 중요합니다:

* `Content-Type: text/calendar; charset=utf-8`
* `Content-Disposition: attachment; filename="run-plan.ics"`

이렇게 하면 대부분의 브라우저와 모바일 OS가 응답을 **파일 다운로드**로 처리합니다. iOS Safari의 경우 다운로드 없이도 바로 Calendar 앱으로 연결될 수 있습니다 (파일 내용을 파싱하여). Android Chrome은 파일을 다운로드 한 뒤 열기를 선택하면 해당 ICS를 Google Calendar 등에 import할 수 있습니다.

**일정 등록 UX:**

* 사용자가 `일정 등록하기` 버튼을 클릭하면 `<a>` 태그의 `href`로 `/api/ical/[planId]`를 열도록 구성합니다. 이 앵커 태그에 `download` 속성을 넣으면 일부 브라우저에서 다운로드 동작을 보장하지만, **서버에서 Content-Disposition을 설정**하는 것이 더 확실합니다.
* 모바일에서는 새 창이 뜨지 않고 바로 ICS 처리가 이루어지도록 `target="_self"` 또는 아무 target도 주지 않는 것이 좋습니다. (필요시 `target="_blank"`로 새 탭에서 다운받게 할 수도 있으나, 사용자 흐름상 현재 화면에서 처리되는 편이 낫습니다.)
* 일정 추가 후 사용자는 기기 기본 캘린더 앱에서 세부 사항(시간 변경 등)을 수정할 수 있습니다. 예를 들어, MVP에서는 일정을 생성 시각 기준으로 넣었으므로 실제 뛰는 시간을 다르게 하고 싶다면 캘린더 앱에서 편집해야 합니다. 이 부분은 **안내 텍스트**로 알려줄 수 있습니다. (예: "캘린더 앱에서 시간을 조정하세요.")

**테스트 시나리오:** iOS (Safari)와 안드로이드(Chrome)에서 ICS 버튼 눌렀을 때 각각 동작 확인이 필요합니다. iOS에서는 즉시 캘린더 이벤트 생성 화면이 뜨고, 안드로이드에선 ICS 다운로드 -> 알림에서 탭 -> 캘린더 앱 선택 과정을 거칩니다. 이러한 차이를 문서화하여 사용자에게 미리 안내할지 여부는 추후 결정합니다. (MVP에서는 크게 언급하지 않아도 무방)

### 프롬프트 설계 가이드 (AI Prompt Design Guide)

AI의 성능과 대화 흐름은 어떻게 **프롬프트를 설계**하느냐에 크게 영향을 받습니다. Gemini와 같은 대화형 모델을 제대로 활용하려면, 시스템 메시지나 초기 프롬프트에 명확한 지침을 제공하고, 각 사용자 응답 후 모델이 **어떤 방향으로 답해야 하는지** 가이드해야 합니다. 아래는 효과적인 프롬프트 설계를 위한 지침과 예시입니다.

* **역할 부여:** AI 모델에게 러닝 코치로서의 **역할과 톤**을 부여합니다. 친근하고 전문적인 코치로 행동하도록 합니다. ("당신은 사용자의 러닝 코치 AI입니다..." 등)
* **대화 목표 명시:** 이번 대화의 목적은 하나의 러닝 세션 계획을 완성하는 것이므로, **필요한 정보를 질문 순서**와 함께 설명합니다. (예: "사용자의 러닝 목표, 러닝 시간/거리, 인터벌 희망 여부를 차례로 물어봐라.")
* **단계별 진행:** 한 번에 하나의 질문만 하도록 지시합니다. 사용자가 답하면 다음 질문으로 넘어가며, 모든 답변을 얻었을 때만 최종 계획을 제시하게 합니다.
* **정보 재사용:** 사용자의 답변 내용을 다음 질문 또는 최종 응답에 적극 반영하도록 유도합니다. (예: "사용자가 '다이어트'라고 답하면 칭찬하고, '30분'이라고 하면 그 값을 언급하며 이어가라.")
* **최종 응답 형식:** 마지막 응답에는 **러닝 계획 요약**을 포함해야 하므로, 이를 명시합니다. 특히 "총 거리, 총 시간, 평균 페이스"는 **굵게 또는 별도로 표시**하라고 지시하여, UI에서 파싱하거나 사용자가 쉽게 인지하도록 합니다. Markdown을 지원하는 환경이라면 **굵게** 표기(**5km**, **30분** 등)하거나, 특별한 토큰을 넣어 구분할 수도 있습니다.
* **한국어 사용:** 사용자 인터페이스가 한국어이므로, 모델이 모든 질문과 응답을 **한국어로 생성**하도록 명확히 지시합니다. 필요한 경우 영어 단어(예: "interval")를 한국어 설명과 함께 사용합니다. (또는 아예 "인터벌"이라는 용어를 씀)

예시 **시스템 프롬프트** (Pseudo-code로 작성):

```plaintext
[시스템 역할 지시]
당신은 친절하고 똑똑한 러닝 코치 AI입니다. 
사용자와 한국어로 대화하십시오. 

목표: 사용자가 하나의 러닝 세션 계획을 얻을 수 있도록 도와주는 것입니다.

대화 규칙:
- 먼저 사용자에게 인사를 건네고 러닝 목표를 질문하세요.
- 답변을 받으면, 러닝에 할애할 시간(또는 거리)을 물어보세요.
- 그 다음, 인터벌 훈련을 포함하고 싶은지 물어보세요.
- 각 질문에 대해 사용자가 답할 때까지 한 번에 하나의 질문만 하십시오.
- 모든 필요한 정보를 얻으면, 러닝 세션 계획을 상세히 설명하는 최종 답변을 제공합니다.

최종 답변 구성:
- 러닝 계획을 단계별로 제시: 워밍업, 본 훈련(인터벌 세부 내용 포함 여부), 쿨다운 등을 기술.
- 친근한 조언이나 응원의 말투를 유지합니다.
- 마지막 부분에 이번 러닝의 "**총 거리**, **총 시간**, **평균 페이스**"를 요약하여 명시합니다.
  예: "총 거리: 5km, 총 시간: 30분, 평균 페이스: 6:00/km"
- 답변 맨 끝에 일정 등록 버튼을 나타내는 텍스트 '[일정 등록하기]'를 추가합니다.

기타:
- 사용자 답변에 유머러스하지 않고 진지하게 공감하세요.
- 필요한 경우 사용자의 모호한 답변을 확인하거나, 제안으로 이끌어 주세요.
```

위와 같은 시스템 프롬프트는 모델이 대화 흐름을 **미리 파악**하고 유도 질문을 생성하는데 도움을 줍니다. 개발자는 이 프롬프트를 Gemini API 호출 시 첫 메시지로 넣고 (`role: system`), 이어서 AI의 첫 질문을 받으면 이를 사용자에게 출력합니다. 그 다음부터는 사용자의 `user` 메시지와 AI의 `assistant` 메시지를 교대로 Gemini API에 전달하여 대화를 진행하면 됩니다.

**프롬프트 팁:**

* 질문을 할 때 **간단명료하게** 묻도록 예시를 줍니다. (시스템 프롬프트에 "러닝 목표를 물어볼 때 예의를 갖추되 짧게 질문" 등의 힌트 포함)
* 최종 답변 예시도 일부 넣어 모델이 형식을 학습하도록 할 수 있습니다. (예: 시스템 메시지에 "응답 예시: ... 총 거리: Xkm, ..." 등을 보여주면 모델이 출력 형식을 더 잘 맞출 수 있습니다.)
* 모델의 응답 길이를 제한하거나 조절하기 위해 "한 번에 5문장 이내로 답변" 같은 내용을 넣을 수도 있습니다. 다만 너무 세세히 제한하면 창의적인 답변이 어려울 수 있으니 필요 최소한으로 둡니다.
* 한국어의 존댓말/반말 여부도 결정해야 합니다. 위 예시에서는 존댓말을 사용했습니다. ("물어보세요", "해주세요" 등) 이는 사용자에게 공손한 인상을 주므로 유지합니다.

**모델 파인튜닝**: Gemini API 자체적으로 대화 스타일을 지정할 수 있다면 (예: temperature, preset, etc.), 적절히 활용합니다. 예를 들어 `temperature`를 0.7\~0.8로 설정해 답변이 창의적이되, 큰 일탈은 없도록 합니다.

### 프로젝트 폴더 구조 및 컴포넌트 역할 (Project Structure & Components)

MVP 구현을 위한 프로젝트 구조와 각 파일/컴포넌트의 역할은 아래와 같습니다. Next.js (Pages Router 기준) 예시로 기술합니다:

```plaintext
/project-root
├── pages
│   ├── index.tsx               # 메인 페이지 - 챗봇 인터페이스 및 요약 카드 렌더링
│   └── api
│       ├── chat.ts             # [POST] 채팅 API - Gemini 호출 및 응답 반환
│       ├── plan.ts             # [POST] 플랜 저장 API - Supabase DB에 계획 저장
│       └── ical
│            └── [id].ts        # [GET] 동적 ICS 생성 API - ID로 플랜 조회, ICS 반환
├── components
│   ├── ChatWindow.tsx          # 채팅 영역 컨테이너 컴포넌트 (헤더, 메시지 리스트 포함)
│   ├── ChatBubble.tsx          # 개별 채팅 말풍선 컴포넌트 (props로 내용과 발신자 타입 받음)
│   ├── ChatInput.tsx           # 하단 입력창 컴포넌트 (텍스트 입력 및 전송 버튼)
│   ├── SummaryCard.tsx         # 최종 결과 요약 카드 컴포넌트 (거리,시간,페이스, 버튼 포함)
│   └── LoadingSpinner.tsx      # (선택) AI 응답 대기중 표시용 로딩 스피너 컴포넌트
├── lib
│   ├── aiClient.ts             # Gemini API 호출 로직 (fetch 함수, API 키 설정 등)
│   ├── supabaseClient.ts       # Supabase 초기화 및 연결 설정
│   └── utils.ts                # 기타 공용 함수 (예: 날짜 포맷팅, pace 계산 등)
├── styles
│   └── globals.css             # Tailwind 기반 글로벌 스타일 (Tailwind baseline reset 등)
├── public
│   └── ...(정적 파일들: 예를 들어 로고 이미지 등)
└── README.md                   # (프로젝트 설명서 및 설정 방법)
```

* **pages/index.tsx:** 메인 UI 페이지로, 전체 애플리케이션을 담는 컴포넌트입니다. 내부에서 `ChatWindow`, `ChatInput`, `SummaryCard` 등을 배치하여 화면을 구성합니다. React 상태 훅(`useState`)을 사용하여 메시지 목록 상태와 최종 플랜 데이터를 관리합니다. 사용자가 메시지를 입력하면 `chat.ts` API를 호출하고, 받은 AI 응답을 상태에 추가하여 다시 렌더링합니다. 최종 메시지를 받으면 SummaryCard 표시용 상태를 갱신합니다.
* **pages/api/chat.ts:** 위 **AI 채팅 API** 명세에 해당하는 구현 파일입니다. 서버측에서 실행되며, 요청으로 들어온 사용자 메시지와 대화 이력을 받아 Gemini(API)에게 요청을 보내고, 응답을 받아 그대로 반환합니다. `aiClient.ts`에 정의된 함수를 호출하여 실제 API 통신을 처리할 수 있습니다. 응답은 JSON 형태로, 에러 시 적절한 HTTP 코드와 메시지를 리턴합니다.
* **pages/api/plan.ts:** **플랜 저장 API** 구현입니다. Supabase 클라이언트를 이용해 request의 JSON payload를 `plans` 테이블에 삽입합니다. 성공 시 생성된 plan ID를 응답하고, 실패 시 오류를 반환합니다. (참고: 이 API는 보안을 위해 간단한 검증만 수행하면 되지만, 악의적 사용을 크게 걱정할 필요는 없습니다. 그래도 POST 요청이므로 CSRF 대비를 위해 Next.js가 제공하는 CSRF 보호 또는 무작위 토큰을 사용할 수도 있습니다.)
* **pages/api/ical/\[id].ts:** **ICS 생성 API** 구현입니다. 동적 경로로 설정하여, 요청 URL의 `[id]` 매개변수를 받아 해당 ID를 DB에서 조회합니다. `supabaseClient`를 사용해 DB 연결 및 조회 쿼리를 실행하고, 결과가 있으면 ICS 문자열을 생성하여 `res.setHeader`와 `res.send()`로 반환합니다. Next.js API Route는 기본적으로 8MB 정도의 응답 제한이 있지만 ICS는 매우 작으므로 문제없습니다.
* **components/ChatWindow\.tsx:** 채팅 UI의 컨테이너 컴포넌트입니다. 내부에 제목(옵션), 메시지 리스트, 입력창 등을 포함합니다. 스타일 상 `max-width`를 적절히 지정하여 너무 넓어지지 않도록 하고, 가운데 정렬을 유지합니다. 초기 렌더링 시 환영 인사 메시지를 상태에 넣어 이 컴포넌트에서 표시할 수도 있습니다 (AI의 첫 메시지를 받기 전 미리 보여주거나, 첫 API 호출로 받아서 표시).
* **components/ChatBubble.tsx:** 개별 메시지를 렌더링하는 컴포넌트로, `message`와 `sender`(혹은 `isUser` boolean) 등의 props를 받아서 내용과 스타일을 결정합니다. sender가 "user"이면 우측 정렬 + 사용자 스타일, "ai"이면 좌측 정렬 + AI 스타일을 적용합니다. HTML 구조상 `<div className="flex justify-end">` 등의 컨테이너를 써서 정렬하고, 내부에 `<div className="rounded-lg border px-4 py-2 bg-white ...">` 형태로 말풍선을 구성합니다.
* **components/ChatInput.tsx:** 텍스트 입력과 전송 버튼을 관리합니다. 사용자가 입력을 완료하고 보내면 부모 컴포넌트(`ChatWindow` 혹은 `index.tsx`)의 콜백을 호출하여 API 연동 및 상태 업데이트를 처리하게 합니다. Enter 키를 눌러도 전송되도록 폼 onSubmit을 활용합니다. Tailwind로 `border rounded-full px-4 py-2` 등 스타일 적용.
* **components/SummaryCard.tsx:** 최종 결과를 보여주는 카드 컴포넌트입니다. props로 러닝 플랜 데이터(거리, 시간, 페이스, 상세 등)를 받아 렌더링합니다. 내부에는 주요 수치를 큰 글씨 혹은 볼드로 강조하고, 세부 계획은 작은 글씨 리스트(`<ul>`)로 정렬합니다. 또한 "일정 등록하기" 버튼 (`AddToCalendarButton`)을 포함합니다. 이 버튼은 `<a>` 태그로 구현하여 `/api/ical/[id]`로 링크되며, 클릭 시 ICS 파일을 얻습니다. SummaryCard는 이 버튼의 href를 생성하기 위해 plan ID가 필요하므로, 해당 ID도 props로 전달받습니다.
* **components/LoadingSpinner.tsx (선택):** AI 응답이 올 때까지 표시할 로딩 스피너입니다. 작은 원형 로딩이나 "Typing..." 텍스트를 채팅창에 넣어, 응답 지연 시 사용자에게 대기 중임을 알립니다. 구현은 간단한 CSS 애니메이션이나 Tailwind의 `animate-spin` 유틸을 사용합니다.
* **lib/aiClient.ts:** Gemini AI API와 통신하는 로직을 캡슐화합니다. 예를 들어 `async function sendMessage(messages): Promise<string>` 형태로 함수 하나를 두고, 내부에서 `fetch`로 Google API endpoint에 POST 요청을 보냅니다. 이때 Authorization 헤더로 API 키를 설정하고, 모델 파라미터(예: temperature, top\_p 등)를 JSON에 포함합니다. 응답 처리 및 에러 처리를 공통화하여 `chat.ts`에서 호출합니다.
* **lib/supabaseClient.ts:** Supabase JS SDK를 초기화합니다. URL과 공개 익명 키 (`NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`)를 이용해 클라이언트를 만들고, `auth`는 사용하지 않는 형태로 설정합니다. 서버측에서 서비스 키를 써야 하는 경우 (예: DB 삽입)에는 해당 API Route 파일 내에서 Supabase Admin client를 생성하거나, Edge Function을 대신 사용합니다. (보안상 service\_role 키는 클라이언트에 노출 금지)
* **lib/utils.ts:** 공용으로 사용하는 유틸 함수들을 모아둡니다. 예: 날짜를 ICS format (`YYYYMMDDTHHMMSS`)으로 포맷하는 함수, "분/km" 페이스를 계산하거나 표기 포맷을 만드는 함수, 텍스트에서 불필요한 공백 제거 함수 등이 있을 수 있습니다.
* **styles/globals.css:** Tailwind CSS 세팅용 글로벌 스타일시트입니다. Tailwind 초기화(`@tailwind base; @tailwind components; @tailwind utilities;`)와 함께 기본 box-sizing 등 Reset 스타일이 포함됩니다. 또한 custom 클래스를 정의해야 하면 여기에 추가합니다. (MVP에선 대부분 Tailwind 유틸로 커버 가능)
* **README.md:** 개발자를 위한 프로젝트 설정 및 실행 방법을 문서화합니다. (예: "npm install", 환경변수 설정, `npm run dev`로 실행, Supabase 세팅 안내, etc.) MVP 결과물이기 때문에 사용자 설명서보다 개발 설치 안내 중심으로 기술합니다.

**환경 변수 및 설정:**

* 프로젝트 루트에 `.env.local` 파일 등을 사용하여 **API Key**와 **DB 연결 정보**를 넣습니다. 예를 들어:

  ```
  NEXT_PUBLIC_SUPABASE_URL=https://xyzcompany.supabase.co
  NEXT_PUBLIC_SUPABASE_ANON_KEY=public-anon-key
  SUPABASE_SERVICE_ROLE_KEY=your-secret-service-key
  GEMINI_API_KEY=your-gemini-api-key
  ```

  Next.js에서는 `NEXT_PUBLIC_` prefix가 붙은 변수는 클라이언트에서도 접근 가능 (노출 가능)하도록 하고, 그렇지 않은 변수(예: 서비스 롤 키, Gemini 키)는 서버 전용으로 사용합니다. API Route에서 `process.env.GEMINI_API_KEY` 식으로 불러와 사용합니다.
* Tailwind 설정 (`tailwind.config.js`)에서 프로젝트에 맞게 경로설정과 테마 확장을 할 수 있으나, MVP 단계에서는 기본 설정으로 충분합니다.

**컴포넌트 간 데이터 흐름:**

* `index.tsx` (혹은 상위 Chat 관리 컴포넌트)에서 메시지 리스트 상태와 최종 플랜 상태를 관리. 이 state를 하위 `ChatWindow`와 `SummaryCard`에 props로 넘김.
* 사용자가 메시지 입력 → `ChatInput` 호출 → 상위 컴포넌트에서 API 호출 → 응답 받으면 메시지 리스트 업데이트 → React 재렌더링으로 `ChatBubble` 목록 갱신.
* 최종 메시지를 받으면, 그 내용(문자열)에서 **총 시간/거리/페이스 등의 키워드**를 찾아내거나, 보다 정확히는 이전 대화 맥락 + AI 응답을 보고 이 시점이 플랜 완료임을 인지 (예: `isFinal` 플래그나 메시지에 "\[러닝 세션 계획]" 같은 사전 정의 텍스트 확인)하여 플랜 완료 처리를 합니다.

  * 플랜 완료 처리: AI 응답을 요약해서 `SummaryCard`에 넘길 데이터 객체를 생성. 이때 AI 응답을 파싱하거나, 이미 AI가 구조화해서 줬다면 바로 사용. (MVP에서는 AI 답변이 비정형 텍스트이므로 정규식 등을 통해 수치 추출할 수 있음. 예: `/총 거리:\s*([\d.]+)km/` 로 거리 찾기 등. 하지만 완벽하지 않을 수 있으므로 프롬프트에서 아예 JSON 출력 기능을 쓰는 방법도 고려 가능. 현재는 단순 추출로 충분.)
  * Supabase에 plan 저장: 추출한 데이터 객체를 `POST /api/plan`에 보내 DB 저장 및 planId 획득. 받은 planId를 SummaryCard 상태에 포함시킵니다.
  * SummaryCard 렌더: plan 요약과 함께 planId 기반으로 `일정 등록하기` 버튼 링크(`/api/ical/[planId]`)를 생성하여 사용.
* "일정 등록하기" 버튼 클릭 → ICS API 호출 (브라우저에서 GET) → ICS 파일 다운로드/열림 → 완료 후 (혹은 중간) UI에서 적절히 피드백 표시.

**결론:** 이 러닝 세션 대화형 플래너 MVP는 **전체적인 흐름**(대화 → 플랜 생성 → 일정 등록)이 매끄럽게 동작하도록 기획되었으며, 기술 스택과 컴포넌트 구조도 이를 뒷받침하도록 구성되었습니다. 실제 구현 시 여기 제시된 구조와 가이드를 따라 개발하면, 최소한의 기능으로 원하는 결과물을 얻을 수 있을 것입니다. 이후 확장이나 개선 (예: 사용자 프로필, 여러 계획 저장, 추가 질문 항목 등)도 이 기반 위에서 진행할 수 있도록 설계되었습니다. 성공적인 MVP 구현을 위한 가이드라인은 이 문서로 충분하며, 개발 진행 중에도 본 기획의 **흐름과 요구사항**을 지속적으로 참조하면 큰 무리 없이 목표를 달성할 수 있을 것입니다.